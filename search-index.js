var searchIndex = {};
searchIndex["bitstream_io"] = {"doc":"Traits and helpers for bitstream handling functionality","items":[[3,"BigEndian","bitstream_io","Big-endian, or most significant bits first",null,null],[3,"LittleEndian","","Little-endian, or least significant bits first",null,null],[3,"BitQueue","","A queue for efficiently pushing bits onto a value and popping them off a value.",null,null],[0,"read","","Traits and implementations for reading bits from a stream.",null,null],[3,"BitReader","bitstream_io::read","For reading non-aligned bits from a stream of bytes in a given endianness.",null,null],[11,"new","","Wraps a BitReader around something that implements `Read`",0,{"inputs":[{"name":"read"}],"output":{"name":"bitreader"}}],[11,"read_bit","","Reads a single bit from the stream. `true` indicates 1, `false` indicates 0",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read","","Reads an unsigned value from the stream with the given number of bits.",0,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"skip","","Skips the given number of bits in the stream. Since this method does not need an accumulator, it may be slightly faster than reading to an empty variable. In addition, since there is no accumulator, there is no upper limit on the number of bits which may be skipped. These bits are still read from the stream, however, and are never skipped via a `seek` method.",0,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"read_bytes","","Completely fills the given buffer with whole bytes. If the stream is already byte-aligned, it will typically map to a faster `read_exact` call.  Otherwise it will read bytes individually in 8-bit increments.",0,null],[11,"read_unary0","","Counts the number of 1 bits in the stream until the next 0 bit and returns the amount read. Because this field is variably-sized and may be large, its output is always a `u32` type.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_unary1","","Counts the number of 0 bits in the stream until the next 1 bit and returns the amount read. Because this field is variably-sized and may be large, its output is always a `u32` type.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"byte_aligned","","Returns true if the stream is aligned at a whole byte.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"byte_align","","Throws away all unread bit values until the next whole byte. Does nothing if the stream is already aligned.",0,{"inputs":[{"name":"self"}],"output":null}],[11,"read_huffman","","Given a compiled Huffman tree, reads bits from the stream until the next symbol is encountered.",0,null],[11,"into_unread","","Consumes reader and returns any un-read partial byte as a `(bits, value)` tuple.",0,null],[11,"read_signed","","Reads a twos-complement signed value from the stream with the given number of bits. Returns an error if the output type is too small to hold the requested number of bits.",0,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"read_signed","","Reads a twos-complement signed value from the stream with the given number of bits. Returns an error if the output type is too small to hold the requested number of bits.",0,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[0,"write","bitstream_io","Traits and implementations for writing bits to a stream.",null,null],[3,"BitWriter","bitstream_io::write","For writing bit values to an underlying stream in a given endianness.",null,null],[11,"new","","Wraps a BitWriter around something that implements `Write`",1,{"inputs":[{"name":"write"}],"output":{"name":"bitwriter"}}],[11,"write_bit","","Writes a single bit to the stream. `true` indicates 1, `false` indicates 0",1,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"write","","Writes an unsigned value to the stream using the given number of bits.",1,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"u"}],"output":{"name":"result"}}],[11,"write_bytes","","Writes the entirety of a byte buffer to the stream. If the stream is already byte-aligned, it will often map to a faster `write_all` call.  Otherwise it will write bytes individually in 8-bit increments.",1,null],[11,"write_huffman","","Writes Huffman code for the given symbol to the stream.",1,{"inputs":[{"name":"self"},{"name":"writehuffmantree"},{"name":"t"}],"output":{"name":"result"}}],[11,"write_unary0","","Writes `value` number of 1 bits to the stream and then writes a 0 bit.  This field is variably-sized.",1,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"write_unary1","","Writes `value` number of 0 bits to the stream and then writes a 1 bit.  This field is variably-sized.",1,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"byte_aligned","","Returns true if the stream is aligned at a whole byte.",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"byte_align","","Pads the stream with 0 bits until it is aligned at a whole byte. Does nothing if the stream is already aligned.",1,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"into_unwritten","","Consumes writer and returns any un-written partial byte as a `(bits, value)` tuple.",1,null],[11,"write_signed","","Writes a twos-complement signed value to the stream with the given number of bits.",1,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"s"}],"output":{"name":"result"}}],[11,"write_signed","","Writes a twos-complement signed value to the stream with the given number of bits.",1,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"s"}],"output":{"name":"result"}}],[0,"huffman","bitstream_io","Traits and implementations for reading or writing Huffman codes from or to a stream.",null,null],[3,"WriteHuffmanTree","bitstream_io::huffman","A compiled Huffman tree for use with the `write_huffman` method. Returned by `compiled_write_tree`.",null,null],[4,"ReadHuffmanTree","","A compiled Huffman tree element for use with the `read_huffman` method. Returned by `compile_read_tree`.",null,null],[13,"Done","","The final value and new reader state",2,null],[13,"Continue","","Another byte is necessary to determine final value",2,null],[13,"InvalidState","","An invalid reader state has been used",2,null],[4,"HuffmanTreeError","","An error type during Huffman tree compilation.",null,null],[13,"InvalidBit","","One of the bits in a Huffman code is not 0 or 1",3,null],[13,"MissingLeaf","","A Huffman code in the specification has no defined symbol",3,null],[13,"DuplicateLeaf","","The same Huffman code specifies multiple symbols",3,null],[13,"OrphanedLeaf","","A Huffman code is the prefix of some longer code",3,null],[5,"compile_read_tree","","Given a vector of symbol/code pairs, compiles a Huffman tree for reading.",null,{"inputs":[{"name":"vec"}],"output":{"name":"result"}}],[5,"compile_write_tree","","Given a vector of symbol/code pairs, compiles a Huffman tree for writing.",null,{"inputs":[{"name":"vec"}],"output":{"name":"result"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"huffmantreeerror"}],"output":{"name":"bool"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"huffmantreeerror"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"has_symbol","","Returns true if symbol is in tree.",4,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}],[11,"get","","Given symbol, returns (bits, value) pairs for writing code. Panics if symbol is not found.",4,null],[6,"BE","bitstream_io","Big-endian, or most significant bits first",null,null],[6,"LE","","Little-endian, or least significant bits first",null,null],[8,"Numeric","","This trait extends many common integer types (both unsigned and signed) with a few trivial methods so that they can be used with the bitstream handling traits.",null,null],[10,"one","","The value of 1 in this type",5,{"inputs":[],"output":{"name":"self"}}],[10,"is_zero","","Returns true if this value is 0, in its type",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"from_u8","","Returns a `u8` value in this type",5,{"inputs":[{"name":"u8"}],"output":{"name":"self"}}],[10,"to_u8","","Assuming 0 <= value < 256, returns this value as a `u8` type",5,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[10,"count_ones","","Counts the number of 1 bits",5,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"leading_zeros","","Counts the number of leading zeros",5,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"trailing_zeros","","Counts the number of trailing zeros",5,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"bits_size","","Size of type in bits",5,{"inputs":[],"output":{"name":"u32"}}],[8,"SignedNumeric","","This trait extends many common signed integer types so that they can be used with the bitstream handling traits.",null,null],[10,"is_negative","","Returns true if this value is negative",6,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"as_negative","","Given a two-complement positive value and certain number of bits, returns this value as a negative number.",6,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"self"}}],[10,"as_unsigned","","Given a negative value and a certain number of bits, returns this value as a twos-complement positive number.",6,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"self"}}],[8,"Endianness","","A stream's endianness, or byte order, for determining how bits should be read.",null,null],[10,"push","","Pushes the given bits and value onto an accumulator with the given bits and value.",7,{"inputs":[{"name":"u32"},{"name":"n"},{"name":"u32"},{"name":"n"}],"output":null}],[10,"pop","","Pops a value with the given number of bits from an accumulator with the given bits and value.",7,{"inputs":[{"name":"u32"},{"name":"n"},{"name":"u32"}],"output":{"name":"n"}}],[10,"drop","","Drops the given number of bits from an accumulator with the given bits and value.",7,{"inputs":[{"name":"u32"},{"name":"n"},{"name":"u32"}],"output":null}],[10,"next_zeros","","Returns the next number of 0 bits from an accumulator with the given bits and value.",7,{"inputs":[{"name":"u32"},{"name":"n"}],"output":{"name":"u32"}}],[10,"next_ones","","Returns the next number of 1 bits from an accumulator with the given bits and value.",7,{"inputs":[{"name":"u32"},{"name":"n"}],"output":{"name":"u32"}}],[11,"push","","",8,{"inputs":[{"name":"u32"},{"name":"n"},{"name":"u32"},{"name":"n"}],"output":null}],[11,"pop","","",8,{"inputs":[{"name":"u32"},{"name":"n"},{"name":"u32"}],"output":{"name":"n"}}],[11,"drop","","",8,{"inputs":[{"name":"u32"},{"name":"n"},{"name":"u32"}],"output":null}],[11,"next_zeros","","",8,{"inputs":[{"name":"u32"},{"name":"n"}],"output":{"name":"u32"}}],[11,"next_ones","","",8,{"inputs":[{"name":"u32"},{"name":"n"}],"output":{"name":"u32"}}],[11,"push","","",9,{"inputs":[{"name":"u32"},{"name":"n"},{"name":"u32"},{"name":"n"}],"output":null}],[11,"pop","","",9,{"inputs":[{"name":"u32"},{"name":"n"},{"name":"u32"}],"output":{"name":"n"}}],[11,"drop","","",9,{"inputs":[{"name":"u32"},{"name":"n"},{"name":"u32"}],"output":null}],[11,"next_zeros","","",9,{"inputs":[{"name":"u32"},{"name":"n"}],"output":{"name":"u32"}}],[11,"next_ones","","",9,{"inputs":[{"name":"u32"},{"name":"n"}],"output":{"name":"u32"}}],[11,"new","","Returns a new empty queue",10,{"inputs":[],"output":{"name":"bitqueue"}}],[11,"from_value","","Creates a new queue from the given value with the given size",10,{"inputs":[{"name":"n"},{"name":"u32"}],"output":{"name":"bitqueue"}}],[11,"set","","Sets the queue to a given value with the given number of bits",10,{"inputs":[{"name":"self"},{"name":"n"},{"name":"u32"}],"output":null}],[11,"value","","Consumes the queue and returns its current value",10,{"inputs":[{"name":"self"}],"output":{"name":"n"}}],[11,"len","","Returns the total bits in the queue",10,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"max_len","","Returns the maximum bits the queue can hold",10,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"is_empty","","Returns true if the queue is empty",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_full","","Returns true if the queue is full",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"clear","","Drops all values in the queue",10,{"inputs":[{"name":"self"}],"output":null}],[11,"all_0","","Returns true if all bits remaining in the queue are 0",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"all_1","","Returns true if all bits remaining in the queue are 1",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"push","","Pushes a value with the given number of bits onto the tail of the queue",10,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"n"}],"output":null}],[11,"pop","","Pops a value with the given number of bits from the head of the queue",10,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"n"}}],[11,"drop","","Drops the given number of bits from the head of the queue without returning them.",10,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"pop_0","","Pops all 0 bits up to and including the next 1 bit and returns the amount of 0 bits popped",10,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"pop_1","","Pops all 1 bits up to and including the next 0 bit and returns the amount of 1 bits popped",10,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"to_state","","Returns the state of the queue as a single value which can be used to perform lookups.",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}]],"paths":[[3,"BitReader"],[3,"BitWriter"],[4,"ReadHuffmanTree"],[4,"HuffmanTreeError"],[3,"WriteHuffmanTree"],[8,"Numeric"],[8,"SignedNumeric"],[8,"Endianness"],[3,"BigEndian"],[3,"LittleEndian"],[3,"BitQueue"]]};
initSearch(searchIndex);

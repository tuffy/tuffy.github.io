var searchIndex = {};
searchIndex["bitstream_io"] = {"doc":"Traits and helpers for bitstream handling functionality","items":[[3,"BigEndian","bitstream_io","Big-endian, or most significant bits first",null,null],[3,"LittleEndian","","Little-endian, or least significant bits first",null,null],[3,"BitQueue","","A queue for efficiently pushing bits onto a value and popping them off a value.",null,null],[0,"read","","Traits and implementations for reading bits from a stream.",null,null],[3,"BitReader","bitstream_io::read","For reading non-aligned bits from a stream of bytes in a given endianness.",null,null],[11,"new","","Wraps a BitReader around something that implements `Read`",0,{"inputs":[{"name":"read"}],"output":{"name":"bitreader"}}],[11,"read_bit","","Reads a single bit from the stream. `true` indicates 1, `false` indicates 0",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read","","Reads an unsigned value from the stream with the given number of bits.",0,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"skip","","Skips the given number of bits in the stream. Since this method does not need an accumulator, it may be slightly faster than reading to an empty variable. In addition, since there is no accumulator, there is no upper limit on the number of bits which may be skipped. These bits are still read from the stream, however, and are never skipped via a `seek` method.",0,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"read_bytes","","Completely fills the given buffer with whole bytes. If the stream is already byte-aligned, it will typically map to a faster `read_exact` call.  Otherwise it will read bytes individually in 8-bit increments.",0,null],[11,"read_unary0","","Counts the number of 1 bits in the stream until the next 0 bit and returns the amount read. Because this field is variably-sized and may be large, its output is always a `u32` type.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"read_unary1","","Counts the number of 0 bits in the stream until the next 1 bit and returns the amount read. Because this field is variably-sized and may be large, its output is always a `u32` type.",0,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"byte_aligned","","Returns true if the stream is aligned at a whole byte.",0,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"byte_align","","Throws away all unread bit values until the next whole byte. Does nothing if the stream is already aligned.",0,{"inputs":[{"name":"self"}],"output":null}],[11,"read_huffman","","Given a compiled Huffman tree, reads bits from the stream until the next symbol is encountered.",0,null],[11,"into_unread","","Consumes reader and returns any un-read partial byte as a `(bits, value)` tuple.",0,null],[11,"read_signed","","Reads a twos-complement signed value from the stream with the given number of bits.",0,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"read_signed","","Reads a twos-complement signed value from the stream with the given number of bits.",0,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[0,"write","bitstream_io","Traits and implementations for writing bits to a stream.",null,null],[3,"BitWriter","bitstream_io::write","For writing bit values to an underlying stream in a given endianness.",null,null],[11,"new","","Wraps a BitWriter around something that implements `Write`",1,{"inputs":[{"name":"write"}],"output":{"name":"bitwriter"}}],[11,"write_bit","","Writes a single bit to the stream. `true` indicates 1, `false` indicates 0",1,{"inputs":[{"name":"self"},{"name":"bool"}],"output":{"name":"result"}}],[11,"write","","Writes an unsigned value to the stream using the given number of bits.",1,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"u"}],"output":{"name":"result"}}],[11,"write_bytes","","Writes the entirety of a byte buffer to the stream. If the stream is already byte-aligned, it will often map to a faster `write_all` call.  Otherwise it will write bytes individually in 8-bit increments.",1,null],[11,"write_huffman","","Writes Huffman code for the given symbol to the stream.",1,{"inputs":[{"name":"self"},{"name":"writehuffmantree"},{"name":"t"}],"output":{"name":"result"}}],[11,"write_unary0","","Writes `value` number of 1 bits to the stream and then writes a 0 bit.  This field is variably-sized.",1,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"write_unary1","","Writes `value` number of 0 bits to the stream and then writes a 1 bit.  This field is variably-sized.",1,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"result"}}],[11,"byte_aligned","","Returns true if the stream is aligned at a whole byte.",1,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"byte_align","","Pads the stream with 0 bits until it is aligned at a whole byte. Does nothing if the stream is already aligned.",1,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"into_unwritten","","Consumes writer and returns any un-written partial byte as a `(bits, value)` tuple.",1,null],[11,"write_signed","","Writes a twos-complement signed value to the stream with the given number of bits.",1,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"s"}],"output":{"name":"result"}}],[11,"write_signed","","Writes a twos-complement signed value to the stream with the given number of bits.",1,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"s"}],"output":{"name":"result"}}],[0,"huffman","bitstream_io","Traits and implementations for reading or writing Huffman codes from or to a stream.",null,null],[3,"WriteHuffmanTree","bitstream_io::huffman","A compiled Huffman tree for use with the `write_huffman` method. Returned by `compiled_write_tree`.",null,null],[4,"ReadHuffmanTree","","A compiled Huffman tree element for use with the `read_huffman` method. Returned by `compile_read_tree`.",null,null],[13,"Done","","The final value and new reader state",2,null],[13,"Continue","","Another byte is necessary to determine final value",2,null],[13,"InvalidState","","An invalid reader state has been used",2,null],[4,"HuffmanTreeError","","An error type during Huffman tree compilation.",null,null],[13,"InvalidBit","","One of the bits in a Huffman code is not 0 or 1",3,null],[13,"MissingLeaf","","A Huffman code in the specification has no defined symbol",3,null],[13,"DuplicateLeaf","","The same Huffman code specifies multiple symbols",3,null],[13,"OrphanedLeaf","","A Huffman code is the prefix of some longer code",3,null],[5,"compile_read_tree","","Given a vector of symbol/code pairs, compiles a Huffman tree for reading.",null,{"inputs":[{"name":"vec"}],"output":{"name":"result"}}],[5,"compile_write_tree","","Given a vector of symbol/code pairs, compiles a Huffman tree for writing.",null,{"inputs":[{"name":"vec"}],"output":{"name":"result"}}],[11,"eq","","",3,{"inputs":[{"name":"self"},{"name":"huffmantreeerror"}],"output":{"name":"bool"}}],[11,"clone","","",3,{"inputs":[{"name":"self"}],"output":{"name":"huffmantreeerror"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"has_symbol","","Returns true if symbol is in tree.",4,{"inputs":[{"name":"self"},{"name":"t"}],"output":{"name":"bool"}}],[11,"get","","Given symbol, returns (bits, value) pairs for writing code. Panics if symbol is not found.",4,null],[6,"BE","bitstream_io","Big-endian, or most significant bits first",null,null],[6,"LE","","Little-endian, or least significant bits first",null,null],[8,"Numeric","","This trait extends many common integer types (both unsigned and signed) with a few trivial methods so that they can be used with the bitstream handling traits.",null,null],[10,"one","","The value of 1 in this type",5,{"inputs":[],"output":{"name":"self"}}],[10,"is_zero","","Returns true if this value is 0, in its type",5,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"from_u8","","Returns a `u8` value in this type",5,{"inputs":[{"name":"u8"}],"output":{"name":"self"}}],[10,"to_u8","","Assuming 0 <= value < 256, returns this value as a `u8` type",5,{"inputs":[{"name":"self"}],"output":{"name":"u8"}}],[10,"count_ones","","Counts the number of 1 bits",5,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"leading_zeros","","Counts the number of leading zeros",5,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"trailing_zeros","","Counts the number of trailing zeros",5,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[10,"bits_size","","Size of type in bits",5,{"inputs":[],"output":{"name":"u32"}}],[8,"SignedNumeric","","This trait extends many common signed integer types so that they can be used with the bitstream handling traits.",null,null],[10,"is_negative","","Returns true if this value is negative",6,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[10,"as_negative","","Given a two-complement positive value and certain number of bits, returns this value as a negative number.",6,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"self"}}],[10,"as_unsigned","","Given a negative value and a certain number of bits, returns this value as a twos-complement positive number.",6,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"self"}}],[8,"Endianness","","A stream's endianness, or byte order, for determining how bits should be read.",null,null],[10,"push","","Pushes the given bits and value onto an accumulator with the given bits and value.",7,{"inputs":[{"name":"u32"},{"name":"n"},{"name":"u32"},{"name":"n"}],"output":null}],[10,"pop","","Pops a value with the given number of bits from an accumulator with the given bits and value.",7,{"inputs":[{"name":"u32"},{"name":"n"},{"name":"u32"}],"output":{"name":"n"}}],[10,"drop","","Drops the given number of bits from an accumulator with the given bits and value.",7,{"inputs":[{"name":"u32"},{"name":"n"},{"name":"u32"}],"output":null}],[10,"next_zeros","","Returns the next number of 0 bits from an accumulator with the given bits and value.",7,{"inputs":[{"name":"u32"},{"name":"n"}],"output":{"name":"u32"}}],[10,"next_ones","","Returns the next number of 1 bits from an accumulator with the given bits and value.",7,{"inputs":[{"name":"u32"},{"name":"n"}],"output":{"name":"u32"}}],[11,"push","","",8,{"inputs":[{"name":"u32"},{"name":"n"},{"name":"u32"},{"name":"n"}],"output":null}],[11,"pop","","",8,{"inputs":[{"name":"u32"},{"name":"n"},{"name":"u32"}],"output":{"name":"n"}}],[11,"drop","","",8,{"inputs":[{"name":"u32"},{"name":"n"},{"name":"u32"}],"output":null}],[11,"next_zeros","","",8,{"inputs":[{"name":"u32"},{"name":"n"}],"output":{"name":"u32"}}],[11,"next_ones","","",8,{"inputs":[{"name":"u32"},{"name":"n"}],"output":{"name":"u32"}}],[11,"push","","",9,{"inputs":[{"name":"u32"},{"name":"n"},{"name":"u32"},{"name":"n"}],"output":null}],[11,"pop","","",9,{"inputs":[{"name":"u32"},{"name":"n"},{"name":"u32"}],"output":{"name":"n"}}],[11,"drop","","",9,{"inputs":[{"name":"u32"},{"name":"n"},{"name":"u32"}],"output":null}],[11,"next_zeros","","",9,{"inputs":[{"name":"u32"},{"name":"n"}],"output":{"name":"u32"}}],[11,"next_ones","","",9,{"inputs":[{"name":"u32"},{"name":"n"}],"output":{"name":"u32"}}],[11,"new","","Returns a new empty queue",10,{"inputs":[],"output":{"name":"bitqueue"}}],[11,"from_value","","Creates a new queue from the given value with the given size",10,{"inputs":[{"name":"n"},{"name":"u32"}],"output":{"name":"bitqueue"}}],[11,"set","","Sets the queue to a given value with the given number of bits",10,{"inputs":[{"name":"self"},{"name":"n"},{"name":"u32"}],"output":null}],[11,"value","","Consumes the queue and returns its current value",10,{"inputs":[{"name":"self"}],"output":{"name":"n"}}],[11,"len","","Returns the total bits in the queue",10,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"max_len","","Returns the maximum bits the queue can hold",10,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"is_empty","","Returns true if the queue is empty",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"is_full","","Returns true if the queue is full",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"clear","","Drops all values in the queue",10,{"inputs":[{"name":"self"}],"output":null}],[11,"all_0","","Returns true if all bits remaining in the queue are 0",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"all_1","","Returns true if all bits remaining in the queue are 1",10,{"inputs":[{"name":"self"}],"output":{"name":"bool"}}],[11,"push","","Pushes a value with the given number of bits onto the tail of the queue",10,{"inputs":[{"name":"self"},{"name":"u32"},{"name":"n"}],"output":null}],[11,"pop","","Pops a value with the given number of bits from the head of the queue",10,{"inputs":[{"name":"self"},{"name":"u32"}],"output":{"name":"n"}}],[11,"drop","","Drops the given number of bits from the head of the queue without returning them.",10,{"inputs":[{"name":"self"},{"name":"u32"}],"output":null}],[11,"pop_0","","Pops all 0 bits up to and including the next 1 bit and returns the amount of 0 bits popped",10,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"pop_1","","Pops all 1 bits up to and including the next 0 bit and returns the amount of 1 bits popped",10,{"inputs":[{"name":"self"}],"output":{"name":"u32"}}],[11,"to_state","","Returns the state of the queue as a single value which can be used to perform lookups.",10,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}]],"paths":[[3,"BitReader"],[3,"BitWriter"],[4,"ReadHuffmanTree"],[4,"HuffmanTreeError"],[3,"WriteHuffmanTree"],[8,"Numeric"],[8,"SignedNumeric"],[8,"Endianness"],[3,"BigEndian"],[3,"LittleEndian"],[3,"BitQueue"]]};
searchIndex["matroska"] = {"doc":"A library for Matroska file metadata parsing functionality","items":[[3,"Matroska","matroska","A Matroska file",null,null],[12,"info","","The file's Info segment",0,null],[12,"tracks","","The file's Tracks segment",0,null],[12,"attachments","","The file's Attachments segment",0,null],[12,"chapters","","The file's Chapters segment",0,null],[3,"Info","","An Info segment with information pertaining to the entire file",null,null],[12,"title","","The file's title",1,null],[12,"duration","","The file's duration",1,null],[12,"date_utc","","Production date",1,null],[12,"muxing_app","","The muxing application or library",1,null],[12,"writing_app","","The writing application",1,null],[3,"Track","","A TrackEntry segment in the Tracks segment container",null,null],[12,"number","","The track number, starting from 1",2,null],[12,"uid","","The track's UID",2,null],[12,"tracktype","","The track's type",2,null],[12,"enabled","","If the track is usable",2,null],[12,"default","","If the track should be active if no other preferences found",2,null],[12,"forced","","If the track must be active during playback",2,null],[12,"interlaced","","If the track contains blocks using lacing",2,null],[12,"defaultduration","","Duration of each frame",2,null],[12,"name","","A human-readable track name",2,null],[12,"language","","The track's language",2,null],[12,"codec_id","","The track's codec's ID",2,null],[12,"codec_name","","The track's codec's human-readable name",2,null],[12,"settings","","The track's audio or video settings",2,null],[3,"Video","","A video track's specifications",null,null],[12,"pixel_width","","Width of encoded video frames in pixels",3,null],[12,"pixel_height","","Height of encoded video frames in pixels",3,null],[12,"display_width","","Width of video frames to display",3,null],[12,"display_height","","Height of video frames to display",3,null],[3,"Audio","","An audio track's specifications",null,null],[12,"sample_rate","","The sample rate in Hz",4,null],[12,"channels","","The number of audio channels",4,null],[12,"bit_depth","","The bit depth of each sample",4,null],[3,"Attachment","","An attached file (often used for cover art)",null,null],[12,"description","","A human-friendly name for the file",5,null],[12,"name","","The file's name",5,null],[12,"mime_type","","The file's MIME type",5,null],[12,"data","","The file's raw data",5,null],[3,"ChapterEdition","","A complete set of chapters",null,null],[12,"hidden","","Whether the chapters should be hidden in the user interface",6,null],[12,"default","","Whether the chapters should be the default",6,null],[12,"ordered","","Whether the order to play chapters is enforced",6,null],[12,"chapters","","The individual chapter entries",6,null],[3,"Chapter","","An individual chapter point",null,null],[12,"time_start","","Timestamp of the start of the chapter",7,null],[12,"time_end","","Timestamp of the end of the chapter",7,null],[12,"hidden","","Whether the chapter point should be hidden in the user interface",7,null],[12,"enabled","","Whether the chapter point should be enabled in the user interface",7,null],[12,"display","","Contains all strings to use for displaying chapter",7,null],[3,"ChapterDisplay","","The display string for a chapter point entry",null,null],[12,"string","","The user interface string",8,null],[12,"language","","The string's language",8,null],[4,"MatroskaError","","A possible error when parsing a Matroska file",null,null],[13,"Io","","An I/O error",9,null],[13,"UTF8","","An error decoding a UTF-8 string",9,null],[13,"InvalidID","","An invalid element ID",9,null],[13,"InvalidSize","","An invalid element size",9,null],[13,"InvalidUint","","An invalid unsigned integer",9,null],[13,"InvalidFloat","","An invalid floating point value",9,null],[13,"InvalidDate","","An invalid date value",9,null],[4,"Tracktype","","The type of a given track",null,null],[13,"Video","","A video track",10,null],[13,"Audio","","An audio track",10,null],[13,"Complex","","A complex track",10,null],[13,"Logo","","A logo track",10,null],[13,"Subtitle","","A subtitle track",10,null],[13,"Buttons","","A buttons track",10,null],[13,"Control","","A controls track",10,null],[13,"Unknown","","An unknown track type",10,null],[4,"Settings","","The settings a track may have",null,null],[13,"None","","No settings (for non audio/video tracks)",11,null],[13,"Video","","Video settings",11,null],[13,"Audio","","Audio settings",11,null],[11,"fmt","","",9,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"open","","Parses contents of open Matroska file",0,{"inputs":[{"name":"file"}],"output":{"name":"result"}}],[11,"video_tracks","","Returns all tracks with a type of \"video\"",0,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"audio_tracks","","Returns all tracks with a type of \"audio\"",0,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"subtitle_tracks","","Returns all tracks with a type of \"subtitle\"",0,{"inputs":[{"name":"self"}],"output":{"name":"vec"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",10,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",10,{"inputs":[{"name":"self"},{"name":"tracktype"}],"output":{"name":"bool"}}],[11,"fmt","","",11,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",3,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",4,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",5,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",6,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",7,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"fmt","","",8,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}]],"paths":[[3,"Matroska"],[3,"Info"],[3,"Track"],[3,"Video"],[3,"Audio"],[3,"Attachment"],[3,"ChapterEdition"],[3,"Chapter"],[3,"ChapterDisplay"],[4,"MatroskaError"],[4,"Tracktype"],[4,"Settings"]]};
initSearch(searchIndex);

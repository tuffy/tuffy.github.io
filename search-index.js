var searchIndex = {};
searchIndex["bitstream_io"] = {"doc":"Traits and helpers for bitstream handling functionality","items":[[3,"BitQueueBE","bitstream_io","A wrapper around some unsigned type to turn it into a big-endian queue.",null,null],[3,"BitQueueLE","","A wrapper around some unsigned type to turn it into a little-endian queue.",null,null],[0,"read","","Traits and implementations for reading bits from a stream.",null,null],[3,"BitReaderBE","bitstream_io::read","A wrapper for reading values from a big-endian stream.",null,null],[3,"BitReaderLE","","A wrapper for reading values from a little-endian stream.",null,null],[8,"BitRead","","For reading bit values from an underlying stream in a given endianness.",null,null],[10,"read","","Reads an unsigned value from the stream with\nthe given number of bits.  This method assumes\nthat the programmer is using an output type\nsufficiently large to hold those bits.",0,null],[10,"read_signed","","Reads a twos-complement signed value from the stream with\nthe given number of bits.  This method assumes\nthat the programmer is using an output type\nsufficiently large to hold those bits.",0,null],[10,"skip","","Skips the given number of bits in the stream.\nSince this method does not need an accumulator,\nit may be slightly faster than reading to an empty variable.\nIn addition, since there is no accumulator,\nthere is no upper limit on the number of bits\nwhich may be skipped.\nThese bits are still read from the stream, however,\nand are never skipped via a `seek` method.",0,null],[10,"read_bytes","","Completely fills the given buffer with whole bytes.\nIf the stream is already byte-aligned, it will map\nto a faster `read_exact` call.  Otherwise it will read\nbytes individually in 8-bit increments.",0,null],[11,"read_unary0","","Counts the number of 1 bits in the stream until the next\n0 bit and returns the amount read.\nBecause this field is variably-sized and may be large,\nits output is always a `u32` type.",0,null],[11,"read_unary1","","Counts the number of 0 bits in the stream until the next\n1 bit and returns the amount read.\nBecause this field is variably-sized and may be large,\nits output is always a `u32` type.",0,null],[10,"byte_aligned","","Returns true if the stream is aligned at a whole byte.",0,null],[10,"byte_align","","Throws away all unread bit values until the next whole byte.",0,null],[11,"new","","Wraps a big-endian reader around a `BufRead` reference.",1,{"inputs":[{"name":"bufread"}],"output":{"name":"bitreaderbe"}}],[11,"read","","",1,null],[11,"skip","","",1,null],[11,"read_signed","","",1,null],[11,"read_bytes","","",1,null],[11,"byte_aligned","","",1,null],[11,"byte_align","","",1,null],[11,"new","","Wraps a little-endian reader around a `BufRead` reference.",2,{"inputs":[{"name":"bufread"}],"output":{"name":"bitreaderle"}}],[11,"read","","",2,null],[11,"skip","","",2,null],[11,"read_signed","","",2,null],[11,"read_bytes","","",2,null],[11,"byte_aligned","","",2,null],[11,"byte_align","","",2,null],[0,"write","bitstream_io","Traits and implementations for writing bits to a stream.",null,null],[3,"BitWriterBE","bitstream_io::write","A wrapper for writing values to a big-endian stream.",null,null],[3,"BitWriterLE","","A wrapper for writing values to a little-endian stream.",null,null],[8,"BitWrite","","For writing bit values to an underlying stream in a given endianness.",null,null],[10,"write","","Writes an unsigned value to the stream using the given\nnumber of bits.  This method assumes that value&#39;s type\nis sufficiently large to hold those bits.",3,null],[10,"write_signed","","Writes a twos-complement signed value to the stream\nwith the given number of bits.  This method assumes\nthat value&#39;s type is sufficiently large to hold those bits.",3,null],[10,"write_bytes","","Writes the entirety of a byte buffer to the stream.\nIf the stream is already byte-aligned, it will often\nmap to a faster `write_all` call.  Otherwise it will\nwrite bytes individually in 8-bit increments.",3,null],[11,"write_unary0","","Writes `value` number of 1 bits to the stream\nand then writes a 0 bit.  This field is variably-sized.",3,null],[11,"write_unary1","","Writes `value` number of 0 bits to the stream\nand then writes a 1 bit.  This field is variably-sized.",3,null],[10,"byte_aligned","","Returns true if the stream is aligned at a whole byte.",3,null],[11,"byte_align","","Pads the stream with 0 bits until is aligned at a whole byte.\nDoes nothing if the stream is already aligned.",3,null],[11,"new","","Wraps a big-endian writer around a `Write` reference.",4,{"inputs":[{"name":"write"}],"output":{"name":"bitwriterbe"}}],[11,"write","","",4,null],[11,"write_signed","","",4,null],[11,"write_bytes","","",4,null],[11,"byte_aligned","","",4,null],[11,"new","","Wraps a little-endian writer around a `Write` reference.",5,{"inputs":[{"name":"write"}],"output":{"name":"bitwriterle"}}],[11,"write","","",5,null],[11,"write_signed","","",5,null],[11,"write_bytes","","",5,null],[11,"byte_aligned","","",5,null],[8,"Numeric","bitstream_io","This trait extends many common integer types (both unsigned and signed)\nwith a few trivial methods so that they can be used\nwith the bitstream handling traits.",null,null],[10,"one","","The value of 1 in this type",6,{"inputs":[],"output":{"name":"self"}}],[10,"is_zero","","Returns true if this value is 0, in its type",6,null],[10,"from_u8","","Returns a `u8` value in this type",6,{"inputs":[{"name":"u8"}],"output":{"name":"self"}}],[10,"to_u8","","Assuming 0 &lt;= value &lt; 256, returns this value as a `u8` type",6,null],[8,"SignedNumeric","","This trait extends many common signed integer types\nso that they can be used with the bitstream handling traits.",null,null],[10,"is_negative","","Returns true if this value is negative",7,null],[10,"as_negative","","Given a two-complement positive value and certain number of bits,\nreturns this value as a negative number.",7,null],[10,"as_unsigned","","Given a negative value and a certain number of bits,\nreturns this value as a twos-complement positive number.",7,null],[8,"BitQueue","","This trait is for treating numeric types as a queue of bits\nwhich values can be pushed to and popped from in\norder to implement bitstream readers and writers.",null,null],[10,"set","","Discards queue&#39;s current status and sets it to new bits and value",8,null],[10,"value","","Consumes queue and returns its internal value",8,null],[10,"len","","Current length of queue, in bits",8,null],[11,"is_empty","","Whether or not the queue is empty",8,null],[11,"clear","","Discards queue&#39;s current status and sets bits and value to 0",8,null],[10,"push","","Pushes a new value onto the back of the queue\nusing the given number of bits.\nMay panic if the total number of bits exceeds\nthe size of the type being pushed onto.",8,null],[10,"pop","","Pops a value from the front of the queue\nwith the given number of bits.\nReturns queue&#39;s whole contents if the requested number of bits\nexceeds the size of the queue.",8,null],[11,"from_value","","Wraps an existing value in a big-endian bit queue\nwith the given number of bits.\nIt is up to the programmer to ensure that the value\nis not larger than the given number of bits can contain.",9,{"inputs":[{"name":"n"},{"name":"u32"}],"output":{"name":"bitqueuebe"}}],[11,"new","","Creates an empty queue with a value and bit count of 0.",9,{"inputs":[],"output":{"name":"bitqueuebe"}}],[11,"set","","",9,null],[11,"value","","",9,null],[11,"len","","",9,null],[11,"push","","",9,null],[11,"pop","","",9,null],[11,"from_value","","Wraps an existing value in a little-endian bit queue\nwith the given number of bits.\nIt is up to the programmer to ensure that the value\nis not larger than the given number of bits can contain.",10,{"inputs":[{"name":"n"},{"name":"u32"}],"output":{"name":"bitqueuele"}}],[11,"new","","Creates an empty queue with a value and bit count of 0.",10,{"inputs":[],"output":{"name":"bitqueuele"}}],[11,"set","","",10,null],[11,"value","","",10,null],[11,"len","","",10,null],[11,"push","","",10,null],[11,"pop","","",10,null]],"paths":[[8,"BitRead"],[3,"BitReaderBE"],[3,"BitReaderLE"],[8,"BitWrite"],[3,"BitWriterBE"],[3,"BitWriterLE"],[8,"Numeric"],[8,"SignedNumeric"],[8,"BitQueue"],[3,"BitQueueBE"],[3,"BitQueueLE"]]};
initSearch(searchIndex);
